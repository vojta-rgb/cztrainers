<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Profil tren√©ra</title>
  <link rel="stylesheet" href="style_main.css"/>
  <link rel="stylesheet" href="navbar.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
</head>
<body>
<!-- Navbar (isolated) -->
  <nav class="cznav" aria-label="Hlavn√≠ navigace">
    <div class="cznav__logo">
      <a href="index_main.html">
        <img src="CZtrainers new better.png" alt="CZTRAINERS Logo" />
      </a>
    </div>

    <!-- Right cluster: profile pill + theme + burger -->
    <div class="cznav__right">
      <a id="profilePill" class="cznav__pill" href="register.html" aria-label="P≈ôihl√°sit / registrace">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
          <circle cx="12" cy="8" r="4"></circle>
          <path d="M6 20a6 6 0 0112 0"></path>
        </svg>
        <span id="pillText">Login</span>
      </a>

      <button id="themeToggle" class="cznav__theme" type="button" aria-label="P≈ôepnout motiv">
        <span id="themeIcon">‚òÄÔ∏è</span>
      </button>

      <button id="hamburger" class="cznav__hamburger" type="button" aria-label="Menu">
        <span></span><span></span><span></span>
      </button>
    </div>

    <!-- Dropdown -->
    <div id="navLinks" class="cznav__menu" role="menu" aria-label="Navigace">
      <a href="index_main.html" class="cznav__link">Dom≈Ø</a>
      <a href="o-nas.html" class="cznav__link">O n√°s</a>
      <a href="login.html" class="cznav__link" id="loginBtn">P≈ôihl√°≈°en√≠</a>
      <a href="#" class="cznav__link" id="logoutBtn" style="display:none">Odhl√°sit se</a>
    </div>
  </nav>

  <div class="container animate__animated animate__fadeIn">
    <h1>Profil u≈æivatele</h1>
    <div id="profileCard" class="profilecard"></div>
  </div>

  <div class="container">
  <div id="profileCard" class="profilecard"></div>

    <!-- REVIEW SYSTEM START -->
    <div id="reviewsSection" class="reviews-container">
      <h2>Recenze</h2>
    <div id="reviewsList" class="reviews-list"></div>

      <div id="reviewFormContainer" class="review-form-container" style="display:none;">
        <label for="reviewRating">Hodnocen√≠:</label>
        <div id="starRating" class="star-rating">
          <span data-value="1">‚òÖ</span>
          <span data-value="2">‚òÖ</span>
          <span data-value="3">‚òÖ</span>
          <span data-value="4">‚òÖ</span>
          <span data-value="5">‚òÖ</span>
        </div>

        <textarea id="reviewText" placeholder="Napi≈°te svou recenzi..." rows="4"></textarea>
        <label class="anon-row"><input type="checkbox" id="reviewAnon"> Odeslat anonymnƒõ</label>
        <button id="submitReview" class="btn primary">Odeslat recenzi</button>
      </div>
      <p id="reviewNotice" class="small"></p>
    </div>
    <!-- REVIEW SYSTEM END -->
  </div>

  <script type="module">
    /* ===== Firebase imports ===== */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, get, set, onValue } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    /* ===== Firebase config ===== */
    const firebaseConfig = {
      apiKey: "AIzaSyASK2terL9kejt9JTJr944WCFYzRkK8AGU",
      authDomain: "cztrainers-dat1.firebaseapp.com",
      databaseURL: "https://cztrainers-dat1-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "cztrainers-dat1",
      storageBucket: "cztrainers-dat1.appspot.com",
      messagingSenderId: "369200533487",
      appId: "1:369200533487:web:eb31707c0de4bda2b8f01a"
    };

    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);
    const auth = getAuth(app);

    /* ===== URL & DOM refs ===== */
    const urlParams   = new URLSearchParams(window.location.search);
    const userId      = urlParams.get("id"); // trainer id whose profile we view
    const profileCard = document.getElementById("profileCard");
      
  function renderSocialLinks(socials = {}) {
      const platforms = {
        instagram: usernameOrUrl =>
          usernameOrUrl?.startsWith("http")
            ? usernameOrUrl
            : `https://instagram.com/${String(usernameOrUrl).replace(/^@/, "")}`,
        facebook: usernameOrUrl =>
          usernameOrUrl?.startsWith("http")
            ? usernameOrUrl
            : `https://facebook.com/${String(usernameOrUrl).replace(/^@/, "")}`,
        tiktok: usernameOrUrl =>
          usernameOrUrl?.startsWith("http")
            ? usernameOrUrl
            : `https://tiktok.com/@${String(usernameOrUrl).replace(/^@/, "")}`
      };

      let html = "";
      for (let key in platforms) {
        if (socials[key] && String(socials[key]).trim() !== "") {
          const link = platforms[key](socials[key]);
          const displayName = String(socials[key]).startsWith("http")
            ? socials[key]
            : `@${String(socials[key]).replace(/^@/, "")}`;
          html += `<a href="${link}" target="_blank" class="social-tag">${key} ${displayName}</a>`;
        }
      }
      return html || "<p>≈Ω√°dn√© soci√°ln√≠ s√≠tƒõ</p>";
    }

    // ===== Load trainer profile (UNCHANGED LOGIC) =====
    if (userId) {
      const userRef = ref(db, 'users/' + userId);
      get(userRef).then(snapshot => {
        if (snapshot.exists()) {
          const user = snapshot.val();

          const specializations = Array.isArray(user.specializations)
            ? user.specializations.join(', ')
            : (typeof user.specializations === 'string' ? user.specializations : '-');

          const languages = Array.isArray(user.languages)
            ? user.languages.join(', ')
            : (typeof user.languages === 'string' ? user.languages : '-');

          profileCard.innerHTML = `
            <div class="profile-container">
              <div class="profile-left">
                <img class="profile-avatar" src="${user.profilePicture || 'https://placehold.co/300x300?text=Profil'}" alt="Profilov√° fotka">
                <h2>${user.name || "Nezn√°m√Ω"} ${user.prijmeni || ""}</h2>
                <p><strong>üìç Lokalita:</strong> ${user.location || "-"}</p>
                <p><strong>üìû Telefon:</strong> ${user.phone || "-"}</p>
                <p><strong>üìß Email:</strong> ${user.email || "-"}</p>
                <p><strong>üåê Moje soci√°ln√≠ s√≠tƒõ:</strong></p>
                <p> </p>
                <div class="socials-container">
                  ${renderSocialLinks({
                    instagram: user.instagram,
                    facebook: user.facebook,
                    tiktok: user.tiktok
                  })}
                </div>
              </div>
              <div class="profile-right">
                <p class="bio-text"><strong>üßç‚Äç‚ôÇÔ∏è O mnƒõ:</strong> ${user.bio || "-"}</p>
                <p><strong>üí™ Specializace:</strong></p>
                <div class="tag-list">
                  ${(Array.isArray(user.specializations) ? user.specializations : (user.specializations || "").split(","))
                    .map(s => `<span class="tag">${String(s).trim()}</span>`).join("") || "-"}
                </div>
                
                <p><strong>üó£Ô∏è Jazyky:</strong></p>
                <div class="tag-list">
                  ${(Array.isArray(user.languages) ? user.languages : (user.languages || "").split(","))
                    .map(l => `<span class="tag">${String(l).trim()}</span>`).join("") || "-"}
                </div>

                <p><strong>üß† Zku≈°enosti:</strong> ${user.experience || "-"} let</p>
                <p class="pricing-text"><strong>üí∞ Cena:</strong> ${user.pricing || "-"}</p>
              </div>
            </div>
          `;
        } else {
          profileCard.innerHTML = "<p>U≈æivatel nebyl nalezen.</p>";
        }
      }).catch(error => {
        profileCard.innerHTML = `<p>Chyba naƒç√≠t√°n√≠: ${error.message}</p>`;
      });
    } else {
      profileCard.innerHTML = "<p>Chyb√≠ ID u≈æivatele v URL.</p>";
    }
  /* ====== REVIEW SYSTEM (edit + anonymous + verified) ====== */
  const reviewsSection      = document.getElementById("reviewsSection");
  const reviewsList         = document.getElementById("reviewsList");
  const reviewFormContainer = document.getElementById("reviewFormContainer");
  const reviewText          = document.getElementById("reviewText");
  const submitReview        = document.getElementById("submitReview");
  const reviewNotice        = document.getElementById("reviewNotice");
  const starRating          = document.getElementById("starRating");
  const reviewAnon          = document.getElementById("reviewAnon");
  let selectedRating = 0;
  let currentUserId = null;
  let editMode = false;          // if true, we‚Äôre editing our existing review
  let originalCreatedAt = null;  // preserve createdAt on edit

  // ===== Robust Czech profanity check (client-only) =====
  // 1) Try to load bad-words-cz from multiple CDNs
  // 2) If all fail, use a local Czech heuristic (stems + accent/leet normalization)

  let czFilter = null;

  async function loadCzFilter() {
    const urls = [
      "https://esm.sh/bad-words-cz@1.0.4",
      "https://cdn.skypack.dev/bad-words-cz@1.0.4",
      "https://jspm.dev/bad-words-cz@1.0.4"
    ];
    for (const u of urls) {
      try {
        const mod = await import(u);
        const Filter = mod.default || mod; // some CDNs export default
        return new Filter();
      } catch (_) {}
    }
    return null;
  }

  // light Czech normalization (remove diacritics + basic leetspeak)
  function normalizeCz(s) {
    const map = {
      √°:"a", ƒç:"c", ƒè:"d", √©:"e", ƒõ:"e", √≠:"i", ≈à:"n",
      √≥:"o", ≈ô:"r", ≈°:"s", ≈•:"t", √∫:"u", ≈Ø:"u", √Ω:"y", ≈æ:"z",
      √Å:"a", ƒå:"c", ƒé:"d", √â:"e", ƒö:"e", √ç:"i", ≈á:"n",
      √ì:"o", ≈ò:"r", ≈†:"s", ≈§:"t", √ö:"u", ≈Æ:"u", √ù:"y", ≈Ω:"z"
    };
    let t = String(s || "").replace(/./gu, ch => map[ch] ?? ch).toLowerCase();
    t = t
      .replace(/[@]/g,"a").replace(/\$/g,"s")
      .replace(/0/g,"o").replace(/1/g,"i").replace(/3/g,"e")
      .replace(/4/g,"a").replace(/5/g,"s").replace(/7/g,"t");
    // collapse non-letters to spaces
    t = t.replace(/[^a-z0-9]+/g, " ");
    return t;
  }

  // compact Czech stems to catch inflections
  const CZ_STEMS = [
    // core vulgar stems (normalized, no diacritics)
    "kurv","zkurv","prokurv","dojeb","pojeb","vyjeb","najeb","zajeb","jeb",
    "mrdat","mrd","mrdk","promrd","vymrd","odmrd","zasmrd", // keep short "mrd" last in block
    "prc","prcat","vyprc","sprc","opr","naprc",
    "suk","sukat","presuk","vosuk","zasuk",
    "pic","pico","pica","pice","pici","picov","picus","pich",
    "kund","kunda","kundi","kundov","kundis",
    "curak","curaci","curack",
    "kokot","kokota","kokotin","kokotsk",
    "zmrd","zmrdit","zmrde","zmrds",
    "srac","srack","srat","posrat","nasrat","vysrat","osrat",
    "zasran","posran","usran","presr",
    "hovn","prdel","vprdel","doprdel",
    "chcan","chcat","pochcat","nachcat","ochcan",
    "pytelkouli","koule","koure","vykour", // sexual slang stems
    "cecky","kozy","koza≈ôe","kozama","kozat",
    "prsa","prciny","koukatna prsa", // soft adult slang (will still match by stem)
    "krava","svine","prasat","prase","parchant","parch",
    "debil","debiln","idiot","blbec","blbka","blbost","magor","kreten","kripl","retard",
    "sprostak","sprostarn",
    // short english add-ons commonly used in CZ
    "fuck","fucking","shit","bullshit","bitch","asshole","dick","cunt","bastard","niga","niger",
  ];

  function czechHeuristic(text) {
    const t = normalizeCz(text);
    return CZ_STEMS.some(stem => t.includes(stem));
  }

  async function containsBadWords(text) {
    try {
      if (!czFilter) czFilter = await loadCzFilter();
      if (czFilter) return czFilter.isProfane(String(text || ""));
    } catch (e) {
      console.warn("CZ filter CDN failed, using heuristic:", e);
    }
    return czechHeuristic(text);
  }

  // get display name from your DB (users -> trainers, app-users -> normal users)
  async function fetchDisplayName(uid){
    // try trainers collection
    try{
      const s1 = await get(ref(db, `users/${uid}`));
      if (s1.exists() && s1.val()?.name) return s1.val().name;
    }catch{}
    // try app-users
    try{
      const s2 = await get(ref(db, `app-users/${uid}`));
      if (s2.exists() && s2.val()?.name) return s2.val().name;
    }catch{}
    // fallback to Auth
    const u = auth.currentUser;
    return (u && (u.displayName || u.email?.split("@")[0])) || "U≈æivatel";
  }

  // stars (picker)
  if (starRating){
    starRating.querySelectorAll("span").forEach(star=>{
      star.addEventListener("click", ()=>{
        selectedRating = parseInt(star.dataset.value);
        starRating.querySelectorAll("span").forEach(s=>{
          s.classList.toggle("active", parseInt(s.dataset.value) <= selectedRating);
        });
      });
    });
  }

  function reviewCardHTML(r, isMine){
    const stars = Math.max(1, Math.min(5, Number(r.rating)||0));
    const badge = r.verified
      ? '<span class="badge badge--ok" title="Ovƒõ≈ôen√° recenze">‚úî Ovƒõ≈ôeno</span>'
      : '<span class="badge badge--pending" title="ƒåek√° na ovƒõ≈ôen√≠">Neovƒõ≈ôeno</span>';

    return `
      <div class="review-top">
        <div class="review-stars">${"‚òÖ".repeat(stars)}${"‚òÜ".repeat(5 - stars)}</div>
        ${badge}
        ${isMine ? '<button class="btn-plain edit-review" type="button">Upravit</button>' : ""}
      </div>
      <p class="review-text">"${r.text}"</p>
      <p class="review-meta">‚Äî ${r.authorName || "U≈æivatel"}, ${new Date(r.createdAt).toLocaleDateString("cs-CZ")}</p>
    `;
  }

  // load all reviews, render edit button for your own review
  function loadReviews(){
    const rRef = ref(db, `reviews/${userId}`);
    onValue(rRef, snap=>{
      reviewsList.innerHTML = "";
      if (!snap.exists()){
        reviewsList.innerHTML = "<p>Zat√≠m ≈æ√°dn√© recenze.</p>";
        return;
      }
      const all = snap.val();
      Object.keys(all).forEach(uid=>{
        const r = all[uid];
        const card = document.createElement("div");
        card.className = "review-card";
        card.innerHTML = reviewCardHTML(r, currentUserId && uid === currentUserId);
        // hook edit button if it's ours
        if (currentUserId && uid === currentUserId){
          const btn = card.querySelector(".edit-review");
          if (btn){
            btn.addEventListener("click", ()=>{
              // enter edit mode: prefill form
              editMode = true;
              selectedRating = Number(r.rating)||0;
              starRating?.querySelectorAll("span").forEach(s=>{
                s.classList.toggle("active", parseInt(s.dataset.value) <= selectedRating);
              });
              reviewText.value = r.text || "";
              reviewAnon.checked = !!r.anonymous;
              originalCreatedAt = r.createdAt || Date.now();
              reviewFormContainer.style.display = "block";
              reviewNotice.textContent = "Upravujete svou recenzi.";
              submitReview.textContent = "Ulo≈æit zmƒõny";
            });
          }
        }
        reviewsList.appendChild(card);
      });
    }, err=>{
      console.error("Reviews read denied:", err);
      reviewsList.innerHTML = "<p>Nepoda≈ôilo se naƒç√≠st recenze (pr√°va k datab√°zi).</p>";
    });
  }
  loadReviews();

  // auth gate: self-review blocked, one review per user; allow editing
  onAuthStateChanged(auth, async(user)=>{
    if (user){
      currentUserId = user.uid;

      if (user.uid === userId){
        reviewNotice.textContent = "Nem≈Ø≈æete ps√°t recenzi na sebe.";
        return;
      }

      // check if I already have a review (to decide create vs edit default state)
      try{
        const mySnap = await get(ref(db, `reviews/${userId}/${user.uid}`));
        if (mySnap.exists()){
          // user can edit; form hidden by default until they click "Upravit"
          reviewNotice.textContent = "Recenzi m≈Ø≈æete upravit pomoc√≠ tlaƒç√≠tka \"Upravit\".";
          submitReview.textContent = "Odeslat recenzi"; // default label (will change in edit)
        }else{
          // first time ‚Üí show form
          reviewFormContainer.style.display = "block";
          submitReview.textContent = "Odeslat recenzi";
        }
      }catch(e){
        console.error("Check my review failed:", e);
        reviewNotice.textContent = "Nelze ovƒõ≈ôit va≈°e recenze (pr√°va k datab√°zi).";
        return;
      }

      // submit (create or update)
      submitReview.onclick = async ()=>{
        const text = (reviewText?.value || "").trim();
        if (!text){ alert("Recenze nem≈Ø≈æe b√Ωt pr√°zdn√°."); return; }
        if (!selectedRating){ alert("Vyberte hodnocen√≠ (1‚Äì5 hvƒõzdiƒçek)."); return; }
        if (await containsBadWords(text)){ alert("Recenze obsahuje zak√°zan√° slova."); return; }

        // name logic: if anonymous checked -> "U≈æivatel", else resolved name from DB
        const displayName = reviewAnon.checked ? "U≈æivatel" : await fetchDisplayName(user.uid);

        // build data
        const now = Date.now();
        const path = ref(db, `reviews/${userId}/${user.uid}`);

        // on create ‚Üí verified always false
        // on edit   ‚Üí preserve verified and createdAt
        let verified = false;
        let createdAt = now;

        if (editMode){
          try{
            const cur = await get(path);
            if (cur.exists()){
              const curVal = cur.val();
              verified = !!curVal.verified;        // keep whatever it was (user can't change it)
              createdAt = curVal.createdAt || now; // preserve original timestamp
            }
          }catch{}
        }

        const reviewData = {
          text,
          rating: selectedRating,
          authorId: user.uid,
          authorName: displayName,
          anonymous: !!reviewAnon.checked,
          verified,             // stays as is; initially false on create
          createdAt
        };

        try{
          await set(path, reviewData);
          // reset UI
          editMode = false;
          reviewText.value = "";
          reviewAnon.checked = false;
          selectedRating = 0;
          starRating?.querySelectorAll("span").forEach(s=>s.classList.remove("active"));
          reviewNotice.textContent = "Recenze byla ulo≈æena.";
          reviewFormContainer.style.display = "none";
          submitReview.textContent = "Odeslat recenzi";
        }catch(e){
          console.error("Write review denied:", e);
          alert("Nepoda≈ôilo se ulo≈æit recenzi (pr√°va k datab√°zi).");
        }
      };

    }else{
      currentUserId = null;
      reviewNotice.textContent = "Pro psan√≠ recenze se mus√≠te p≈ôihl√°sit.";
      reviewFormContainer.style.display = "none";
      reviewsSection.addEventListener("click", ()=>{ window.location.href = "register.html"; }, { once:true });
    }
  });
  </script>

  <script type="module" src="auth-navbar.js"></script>
</body>
</html>
