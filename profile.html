<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Profil trenÃ©ra</title>
  <link rel="stylesheet" href="style_main.css"/>
  <link rel="stylesheet" href="navbar.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
</head>
<body>
<!-- Navbar (isolated) -->
  <nav class="cznav" aria-label="HlavnÃ­ navigace">
    <div class="cznav__logo">
      <a href="index_main.html">
        <img src="CZtrainers new better.png" alt="CZTRAINERS Logo" />
      </a>
    </div>

    <!-- Right cluster: profile pill + theme + burger -->
    <div class="cznav__right">
      <a id="profilePill" class="cznav__pill" href="register.html" aria-label="PÅ™ihlÃ¡sit / registrace">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
          <circle cx="12" cy="8" r="4"></circle>
          <path d="M6 20a6 6 0 0112 0"></path>
        </svg>
        <span id="pillText">Login</span>
      </a>

      <button id="themeToggle" class="cznav__theme" type="button" aria-label="PÅ™epnout motiv">
        <span id="themeIcon">â˜€ï¸</span>
      </button>

      <button id="hamburger" class="cznav__hamburger" type="button" aria-label="Menu">
        <span></span><span></span><span></span>
      </button>
    </div>

    <!-- Dropdown -->
    <div id="navLinks" class="cznav__menu" role="menu" aria-label="Navigace">
      <a href="index_main.html" class="cznav__link">DomÅ¯</a>
      <a href="o-nas.html" class="cznav__link">O nÃ¡s</a>
      <a href="login.html" class="cznav__link" id="loginBtn">PÅ™ihlÃ¡Å¡enÃ­</a>
      <a href="#" class="cznav__link" id="logoutBtn" style="display:none">OdhlÃ¡sit se</a>
    </div>
  </nav>

  <div class="container">
    <h1 class="animate__animated animate__fadeInUp">Profil uÅ¾ivatele</h1>
    <div id="profileCard" class="profilecard"></div>
  </div>

  <div class="container">
  <div id="profileCard" class="profilecard"></div>

    <!-- REVIEW SYSTEM START -->
    <div id="reviewsSection" class="reviews-container">
      <h2>Recenze</h2>
    <div id="reviewsList" class="reviews-list"></div>

      <div id="reviewFormContainer" class="review-form-container" style="display:none;">
        <label for="reviewRating">HodnocenÃ­:</label>
        <div id="starRating" class="star-rating">
          <span data-value="1">â˜…</span>
          <span data-value="2">â˜…</span>
          <span data-value="3">â˜…</span>
          <span data-value="4">â˜…</span>
          <span data-value="5">â˜…</span>
        </div>

        <textarea id="reviewText" placeholder="NapiÅ¡te svou recenzi..." rows="4"></textarea>
        <label class="anon-row"><input type="checkbox" id="reviewAnon"> Odeslat anonymnÄ›</label>
        <button id="submitReview" class="btn primary">Odeslat recenzi</button>
      </div>
      <p id="reviewNotice" class="small"></p>
    </div>
    <!-- REVIEW SYSTEM END -->
  </div>

  <div id="toast" class="toast"></div>

  <script type="module">
    /* ===== Firebase imports ===== */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getDatabase, ref, get, set, onValue } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    /* ===== Firebase config ===== */
    const firebaseConfig = {
      apiKey: "AIzaSyASK2terL9kejt9JTJr944WCFYzRkK8AGU",
      authDomain: "cztrainers-dat1.firebaseapp.com",
      databaseURL: "https://cztrainers-dat1-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "cztrainers-dat1",
      storageBucket: "cztrainers-dat1.appspot.com",
      messagingSenderId: "369200533487",
      appId: "1:369200533487:web:eb31707c0de4bda2b8f01a"
    };

    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);
    const auth = getAuth(app);

    /* ===== URL & DOM refs ===== */
    const urlParams   = new URLSearchParams(window.location.search);
    const userId      = urlParams.get("id"); // trainer id whose profile we view
    const profileCard = document.getElementById("profileCard");
      
    function renderSocialLinks(socials = {}) {
      const platforms = {
        instagram: usernameOrUrl =>
          usernameOrUrl?.startsWith("http")
            ? usernameOrUrl
            : `https://instagram.com/${String(usernameOrUrl).replace(/^@/, "")}`,
        facebook: usernameOrUrl =>
          usernameOrUrl?.startsWith("http")
            ? usernameOrUrl
            : `https://facebook.com/${String(usernameOrUrl).replace(/^@/, "")}`,
        tiktok: usernameOrUrl =>
          usernameOrUrl?.startsWith("http")
            ? usernameOrUrl
            : `https://tiktok.com/@${String(usernameOrUrl).replace(/^@/, "")}`
      };

      let html = "";
      for (let key in platforms) {
        if (socials[key] && String(socials[key]).trim() !== "") {
          const link = platforms[key](socials[key]);
          const displayName = String(socials[key]).startsWith("http")
            ? socials[key]
            : `@${String(socials[key]).replace(/^@/, "")}`;
          html += `<a href="${link}" target="_blank" class="social-tag">${key} ${displayName}</a>`;
        }
      }
      return html || "<p>Å½Ã¡dnÃ© sociÃ¡lnÃ­ sÃ­tÄ›</p>";
    }

    // ===== Load trainer profile (UNCHANGED LOGIC) =====
    if (userId) {
      const userRef = ref(db, 'users/' + userId);
      get(userRef).then(snapshot => {
        if (snapshot.exists()) {
          const user = snapshot.val();

          const specializations = Array.isArray(user.specializations)
            ? user.specializations.join(', ')
            : (typeof user.specializations === 'string' ? user.specializations : '-');

          const languages = Array.isArray(user.languages)
            ? user.languages.join(', ')
            : (typeof user.languages === 'string' ? user.languages : '-');

          profileCard.innerHTML = `
            <div class="profile-container animate__animated animate__fadeIn animate__slow">
              <div class="profile-left">
                <img class="profile-avatar" src="${user.profilePicture || 'https://placehold.co/300x300?text=Profil'}" alt="ProfilovÃ¡ fotka">
                <h2>${user.name || "NeznÃ¡mÃ½"} ${user.prijmeni || ""}</h2>
                <p><strong>ğŸ“ Lokalita:</strong> ${user.location || "-"}</p>
                <p><strong>ğŸ“ Telefon:</strong> ${user.phone || "-"}</p>
                <p><strong>ğŸ“§ Email:</strong> ${user.email || "-"}</p>
                <p><strong>ğŸŒ Moje sociÃ¡lnÃ­ sÃ­tÄ›:</strong></p>
                <p> </p>
                <div class="socials-container">
                  ${renderSocialLinks({
                    instagram: user.instagram,
                    facebook: user.facebook,
                    tiktok: user.tiktok
                  })}
                </div>
              </div>
              <div class="profile-right">
                <p class="bio-text"><strong>ğŸ§â€â™‚ï¸ O mnÄ›:</strong> ${user.bio || "-"}</p>
                <p><strong>ğŸ’ª Specializace:</strong></p>
                <div class="tag-list">
                  ${(Array.isArray(user.specializations) ? user.specializations : (user.specializations || "").split(","))
                    .map(s => `<span class="tag">${String(s).trim()}</span>`).join("") || "-"}
                </div>
                
                <p><strong>ğŸ—£ï¸ Jazyky:</strong></p>
                <div class="tag-list">
                  ${(Array.isArray(user.languages) ? user.languages : (user.languages || "").split(","))
                    .map(l => `<span class="tag">${String(l).trim()}</span>`).join("") || "-"}
                </div>

                <p><strong>ğŸ§  ZkuÅ¡enosti:</strong> ${user.experience || "-"} let</p>
                <p class="pricing-text"><strong>ğŸ’° Cena:</strong> ${user.pricing || "-"}</p>
              </div>
            </div>
          `;
        } else {
          profileCard.innerHTML = "<p>UÅ¾ivatel nebyl nalezen.</p>";
        }
      }).catch(error => {
        profileCard.innerHTML = `<p>Chyba naÄÃ­tÃ¡nÃ­: ${error.message}</p>`;
      });
    } else {
      profileCard.innerHTML = "<p>ChybÃ­ ID uÅ¾ivatele v URL.</p>";
    }

    /* ====== REVIEW SYSTEM (edit + anonymous + verified) ====== */
    const reviewsSection      = document.getElementById("reviewsSection");
    const reviewsList         = document.getElementById("reviewsList");
    const reviewFormContainer = document.getElementById("reviewFormContainer");
    const reviewText          = document.getElementById("reviewText");
    const submitReview        = document.getElementById("submitReview");
    const reviewNotice        = document.getElementById("reviewNotice");
    const starRating          = document.getElementById("starRating");
    const reviewAnon          = document.getElementById("reviewAnon");
    let selectedRating = 0;
    let currentUserId = null;
    let editMode = false;          // if true, weâ€™re editing our existing review
    let originalCreatedAt = null;  // preserve createdAt on edit
    
    // --- tiny toast (no alert) ---
    const toastEl = document.getElementById("toast");
    function toast(msg){
      if(!toastEl) return;
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(()=> toastEl.classList.remove("show"), 2200);
    }

    // ===== Robust Czech profanity check (client-only) =====
    // 1) Try to load bad-words-cz from multiple CDNs
    // 2) If all fail, use a local Czech heuristic (stems + accent/leet normalization)

    let czFilter = null;

    async function loadCzFilter() {
      const urls = [
        "https://esm.sh/bad-words-cz@1.0.4",
        "https://cdn.skypack.dev/bad-words-cz@1.0.4",
        "https://jspm.dev/bad-words-cz@1.0.4"
      ];
      for (const u of urls) {
        try {
          const mod = await import(u);
          const Filter = mod.default || mod; // some CDNs export default
          return new Filter();
        } catch (_) {}
      }
      return null;
    }

    // light Czech normalization (remove diacritics + basic leetspeak)
    function normalizeCz(s) {
      const map = {
        Ã¡:"a", Ä:"c", Ä:"d", Ã©:"e", Ä›:"e", Ã­:"i", Åˆ:"n",
        Ã³:"o", Å™:"r", Å¡:"s", Å¥:"t", Ãº:"u", Å¯:"u", Ã½:"y", Å¾:"z",
        Ã:"a", ÄŒ:"c", Ä:"d", Ã‰:"e", Äš:"e", Ã:"i", Å‡:"n",
        Ã“:"o", Å˜:"r", Å :"s", Å¤:"t", Ãš:"u", Å®:"u", Ã:"y", Å½:"z"
      };
      let t = String(s || "").replace(/./gu, ch => map[ch] ?? ch).toLowerCase();
      t = t
        .replace(/[@]/g,"a").replace(/\$/g,"s")
        .replace(/0/g,"o").replace(/1/g,"i").replace(/3/g,"e")
        .replace(/4/g,"a").replace(/5/g,"s").replace(/7/g,"t");
      // collapse non-letters to spaces
      t = t.replace(/[^a-z0-9]+/g, " ");
      return t;
    }

    // compact Czech stems to catch inflections
    const CZ_STEMS = [
      // core vulgar stems (normalized, no diacritics)
      "kurv","zkurv","prokurv","dojeb","pojeb","vyjeb","najeb","zajeb","jeb",
      "mrdat","mrd","mrdk","promrd","vymrd","odmrd","zasmrd",
      "prc","prcat","vyprc","sprc","opr","naprc",
      "suk","sukat","presuk","vosuk","zasuk",
      "pic","pico","pica","pice","pici","picov","picus","pich",
      "kund","kunda","kundi","kundov","kundis",
      "curak","curaci","curack",
      "kokot","kokota","kokotin","kokotsk",
      "zmrd","zmrdit","zmrde","zmrds",
      "srac","srack","srat","posrat","nasrat","vysrat","osrat",
      "zasran","posran","usran","presr",
      "hovn","prdel","vprdel","doprdel",
      "chcan","chcat","pochcat","nachcat","ochcan",
      "pytelkouli","koule","koure","vykour",
      "cecky","kozy","kozat",
      "prsa","prciny",
      "krava","svine","prasat","prase","parchant","parch",
      "debil","debiln","idiot","blbec","blbka","blbost","magor","kreten","kripl","retard",
      "sprostak","sprostarn",
      "fuck","fucking","shit","bullshit","bitch","asshole","dick","cunt","bastard","niga","niger",
    ];

    function czechHeuristic(text) {
      const t = normalizeCz(text);
      return CZ_STEMS.some(stem => t.includes(stem));
    }

    async function containsBadWords(text) {
      try {
        if (!czFilter) czFilter = await loadCzFilter();
        if (czFilter) return czFilter.isProfane(String(text || ""));
      } catch (e) {
        console.warn("CZ filter CDN failed, using heuristic:", e);
      }
      return czechHeuristic(text);
    }

    // get display name from your DB (users -> trainers, app-users -> normal users)
    async function fetchDisplayName(uid){
      try{
        const s1 = await get(ref(db, `users/${uid}`));
        if (s1.exists() && s1.val()?.name) return s1.val().name;
      }catch{}
      try{
        const s2 = await get(ref(db, `app-users/${uid}`));
        if (s2.exists() && s2.val()?.name) return s2.val().name;
      }catch{}
      const u = auth.currentUser;
      return (u && (u.displayName || u.email?.split("@")[0])) || "UÅ¾ivatel";
    }

    // stars (picker)
    if (starRating){
      starRating.querySelectorAll("span").forEach(star=>{
        star.addEventListener("click", ()=>{
          selectedRating = parseInt(star.dataset.value);
          starRating.querySelectorAll("span").forEach(s=>{
            s.classList.toggle("active", parseInt(s.dataset.value) <= selectedRating);
          });
        });
      });
    }

    function reviewCardHTML(r, isMine){
      const stars = Math.max(1, Math.min(5, Number(r.rating)||0));
      const badge = r.verified
        ? '<span class="badge badge--ok" title="OvÄ›Å™enÃ¡ recenze">âœ” OvÄ›Å™eno</span>'
        : '<span class="badge badge--pending" title="ÄŒekÃ¡ na ovÄ›Å™enÃ­">NeovÄ›Å™eno</span>';

      return `
        <div class="review-top">
          <div class="review-stars">${"â˜…".repeat(stars)}${"â˜†".repeat(5 - stars)}</div>
          ${badge}
          ${isMine ? '<button class="btn-plain edit-review" type="button">Upravit</button>' : ""}
        </div>
        <p class="review-text">"${r.text}"</p>
        <p class="review-meta">â€” ${r.authorName || "UÅ¾ivatel"}, ${new Date(r.createdAt).toLocaleDateString("cs-CZ")}</p>
      `;
    }

    // load all reviews, render edit button for your own review
    function loadReviews(){
      const rRef = ref(db, `reviews/${userId}`);
      onValue(rRef, snap=>{
        reviewsList.innerHTML = "";
        if (!snap.exists()){
          reviewsList.innerHTML = "<p>ZatÃ­m Å¾Ã¡dnÃ© recenze.</p>";
          return;
        }
        const all = snap.val();
        Object.keys(all).forEach(uid=>{
          const r = all[uid];
          const card = document.createElement("div");
          card.className = "review-card";
          card.innerHTML = reviewCardHTML(r, currentUserId && uid === currentUserId);

          // Attach reporting UI
          card.dataset.reviewerId = uid;                       // who wrote this review
          card.dataset.text       = r.text || "";
          card.dataset.rating     = Number(r.rating) || 0;
          card.dataset.createdAt  = r.createdAt || 0;
          card.dataset.authorName = r.authorName || "UÅ¾ivatel";

          if (currentUserId && currentUserId !== uid) {
            const actions = document.createElement("div");
            actions.className = "review-actions";

            const reportBtn = document.createElement("button");
            reportBtn.className = "report-btn";
            reportBtn.type = "button";
            reportBtn.textContent = "NahlÃ¡sit";
            reportBtn.dataset.rid = uid; // reviewerId

            actions.appendChild(reportBtn);
            card.appendChild(actions);

            // mark as already reported (disable & rename) â€” keep inside same scope as reportBtn
            const alreadyRef = ref(db, `reviewReportsQueue/${userId}/${uid}/${currentUserId}`);
            onValue(alreadyRef, (snap) => {
              if (snap.exists()) {
                reportBtn.disabled = true;
                reportBtn.textContent = "NahlÃ¡Å¡eno";
              }
            }, { onlyOnce: true });
          }

          // hook edit button if it's ours
          if (currentUserId && uid === currentUserId){
            const btn = card.querySelector(".edit-review");
            if (btn){
              btn.addEventListener("click", ()=>{
                // enter edit mode: prefill form
                editMode = true;
                selectedRating = Number(r.rating)||0;
                starRating?.querySelectorAll("span").forEach(s=>{
                  s.classList.toggle("active", parseInt(s.dataset.value) <= selectedRating);
                });
                reviewText.value = r.text || "";
                reviewAnon.checked = !!r.anonymous;
                originalCreatedAt = r.createdAt || Date.now();
                reviewFormContainer.style.display = "block";
                reviewNotice.textContent = "Upravujete svou recenzi.";
                submitReview.textContent = "UloÅ¾it zmÄ›ny";
              });
            }
          }

          reviewsList.appendChild(card);
        });
      }, err=>{
        console.error("Reviews read denied:", err);
        reviewsList.innerHTML = "<p>NepodaÅ™ilo se naÄÃ­st recenze (prÃ¡va k databÃ¡zi).</p>";
      });
    }
    loadReviews();

    // One-click report â†’ writes to moderation queue; one report per user per review
    reviewsList.addEventListener("click", async (e) => {
      const btn = e.target.closest(".report-btn");
      if (!btn) return;

      const user = auth.currentUser;
      if (!user) { toast("Pro nahlÃ¡Å¡enÃ­ se pÅ™ihlaste."); return; }

      // Find the review card and its data
      const card = btn.closest(".review-card");
      if (!card) return;

      const reviewerId = card.dataset.reviewerId;   // author of the review (uid)
      if (!reviewerId) return;

      // Prevent duplicate reports by same user on the same review
      const reportRef = ref(db, `reviewReportsQueue/${userId}/${reviewerId}/${user.uid}`);

      // Prepare a tiny snapshot (helps you moderate even if review later changes)
      const payload = {
        reason: "UÅ¾ivatel nahlÃ¡sil recenzi",
        createdAt: Date.now(),
        reporterUid: user.uid,
        reviewSnapshot: {
          text: card.dataset.text || "",
          rating: Number(card.dataset.rating) || 0,
          createdAt: Number(card.dataset.createdAt) || 0,
          authorName: card.dataset.authorName || "UÅ¾ivatel",
          path: `reviews/${userId}/${reviewerId}` // where it currently lives
        }
      };

      try {
        await set(reportRef, payload); // write once; overwrites if same reporter re-clicks
        // UI feedback (no alert)
        btn.disabled = true;
        btn.textContent = "NahlÃ¡Å¡eno";
        const pill = document.createElement("span");
        pill.className = "reported-pill";
        pill.textContent = "OdeslÃ¡no k moderaci";
        btn.after(pill);

        toast("DÄ›kujeme, nahlÃ¡Å¡enÃ­ bylo odeslÃ¡no.");
      } catch (err) {
        console.error("Report failed:", err);
        toast("NepodaÅ™ilo se odeslat nahlÃ¡Å¡enÃ­.");
      }
    });

    // auth gate: self-review blocked, one review per user; allow editing
    onAuthStateChanged(auth, async(user)=>{
      if (user){
        currentUserId = user.uid;

        if (user.uid === userId){
          reviewNotice.textContent = "NemÅ¯Å¾ete psÃ¡t recenzi na sebe.";
          return;
        }

        // check if I already have a review (to decide create vs edit default state)
        try{
          const mySnap = await get(ref(db, `reviews/${userId}/${user.uid}`));
          if (mySnap.exists()){
            // user can edit; form hidden by default until they click "Upravit"
            reviewNotice.textContent = "Recenzi mÅ¯Å¾ete upravit pomocÃ­ tlaÄÃ­tka \"Upravit\".";
            submitReview.textContent = "Odeslat recenzi"; // default label (will change in edit)
          }else{
            // first time â†’ show form
            reviewFormContainer.style.display = "block";
            submitReview.textContent = "Odeslat recenzi";
          }
        }catch(e){
          console.error("Check my review failed:", e);
          reviewNotice.textContent = "Nelze ovÄ›Å™it vaÅ¡e recenze (prÃ¡va k databÃ¡zi).";
          return;
        }

        // submit (create or update)
        submitReview.onclick = async ()=>{
          const text = (reviewText?.value || "").trim();
          if (!text){ alert("Recenze nemÅ¯Å¾e bÃ½t prÃ¡zdnÃ¡."); return; }
          if (!selectedRating){ alert("Vyberte hodnocenÃ­ (1â€“5 hvÄ›zdiÄek)."); return; }
          if (await containsBadWords(text)){ alert("Recenze obsahuje zakÃ¡zanÃ¡ slova."); return; }

          // name logic: if anonymous checked -> "UÅ¾ivatel", else resolved name from DB
          const displayName = reviewAnon.checked ? "UÅ¾ivatel" : await fetchDisplayName(user.uid);

          // build data
          const now = Date.now();
          const path = ref(db, `reviews/${userId}/${user.uid}`);

          // on create â†’ verified always false
          // on edit   â†’ preserve verified and createdAt
          let verified = false;
          let createdAt = now;

          if (editMode){
            try{
              const cur = await get(path);
              if (cur.exists()){
                const curVal = cur.val();
                verified = !!curVal.verified;        // keep whatever it was (user can't change it)
                createdAt = curVal.createdAt || now; // preserve original timestamp
              }
            }catch{}
          }

          const reviewData = {
            text,
            rating: selectedRating,
            authorId: user.uid,
            authorName: displayName,
            anonymous: !!reviewAnon.checked,
            verified,             // stays as is; initially false on create
            createdAt
          };

          try{
            await set(path, reviewData);
            // reset UI
            editMode = false;
            reviewText.value = "";
            reviewAnon.checked = false;
            selectedRating = 0;
            starRating?.querySelectorAll("span").forEach(s=>s.classList.remove("active"));
            reviewNotice.textContent = "Recenze byla uloÅ¾ena.";
            reviewFormContainer.style.display = "none";
            submitReview.textContent = "Odeslat recenzi";
          }catch(e){
            console.error("Write review denied:", e);
            alert("NepodaÅ™ilo se uloÅ¾it recenzi (prÃ¡va k databÃ¡zi).");
          }
        };

      }else{
        currentUserId = null;
        reviewNotice.textContent = "Pro psanÃ­ recenze se musÃ­te pÅ™ihlÃ¡sit.";
        reviewFormContainer.style.display = "none";
        reviewsSection.addEventListener("click", ()=>{ window.location.href = "register.html"; }, { once:true });
      }
    });
  </script>

  <script type="module" src="auth-navbar.js"></script>
</body>
</html>
